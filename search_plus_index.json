{"./":{"url":"./","title":"Introduction","keywords":"","body":"写在前面 本书的目的是用来记录学习阅读Vue过程中的疑问和收获。Aaron所在的公司技术栈就是Vue，无论是管理端、移动端还是小程序和桌面端几乎所有大大小小的项目都是使用Vue的生态，但是Aaron在写业务的过程中对Vue的掌握一直停留在熟悉API的层面，在遇到疑惑的时候也只是通过搜索和社区去解决部分场景化的问题，对一些概念性、原理性的知识点一直是模糊的，也没有系统地去学习和梳理。所以在Aaron的计划中就有了这本书。 怎么看 Aaron第一次看这种级别的框架，看不懂是理所当然的（先认怂，哈哈哈），所以在参阅了这篇文章👉来聊聊源码学习之后，Aaron找到了三个指导思想：全盘了解、主线优先、问题驱动。 全盘了解 首先你要对这个开源项目要有全盘的了解，知道它产生的背景，来解决什么样的问题。开始看源码前，先对它的源码目录结构、代码执行入口、构建打包方式、最终产出的文件等等有一个整体的了解。需要用一个全局的视野去审视源码，切忌漫无目的的看源码 主线优先 当我们通过问题驱动去看代码的时候，要牢记主线优先，所谓主线就是解决你这个问题核心流程中的代码。因为通常一个开源项目它的功能会很丰富，所以代码分支逻辑会有很多。而当我们带着问题去看源码的时候，切忌像代码执行一样把每个分支逻辑都去看一遍，我们要关心的就是主线部分。分支逻辑通常都是为了解决某些特定场景的问题，那么如果想学习它的话就针对这个场景分析的时候再回来看即可。还是以 Vue.js 为例，比如我们在分析模板是如何驱动 DOM 渲染的，我们只要关心核心流程 init -> mount -> render -> update -> patch 这个过程的实现即可。那么过程中遇到的初始化响应式对象这些分支逻辑，我们就可以先不看，因为当前分析的这个场景并不会有数据更新的部分，而这部分内容我们可以放到深入研究响应式原理的时候再 问题驱动 在全盘了解的基础上，就可以通过问题驱动去看源码了。以 Vue.js 为例，我们知道了它的核心思想是数据驱动 + 组件化，那么我们就可以问自己，Vue 模板的数据是如何渲染到 DOM 上的，数据更新后模板是如何重新渲染的，组件化是如何实现的，模板到 render 函数如何编译的等等。那么每一个问题都可以值得我们针对性地去学习源码。问题驱动的方式和坑驱动不同的地方在于这个学习过程是主动的，自驱的，学到的东西会更加系统和全面；而坑驱动往往都会满足于解决某个问题就停下了，学习会比较局限 阅读技巧 阅读源码也是有很多技巧的，比如关键地方加断点单步调试、复杂函数看单元测试的输入输出、复杂逻辑通过画图辅助以及跟随作者的commit历史记录、查看编译后的代码等 所以Aaron会先从翻社区的文章开始，比如响应式原理，我会先找几篇写得好的文章，总结梳理一下，在脑海里对响应式原理有个大概的轮廓之后再去查看对应的源码，在Aaron的想象中它的每一个章节应该会像一篇篇博客文章一样，先说明概念，然后再查看Vue的具体实现，然后加上Aaron自己的见解（如果有，哈哈哈）。所以在章节上面，Aaron也是会根据自己的情况有先后有顺序地去学习，比如我现在想先搞清$nextTick那我就先去看$nextTick的内容。 目前Vue的稳定版本是2.6.10，因此Aaron就基于这个版本开始学习。 TODO [x] 全局看Vue [x] 响应式原理 [x] 依赖收集 [x] 数据绑定 [ ] VNode节点 [ ] Virtual DOM与diff [ ] template编译 [ ] 异步更新DOM策略及nextTick [ ] keep-alive组件使用及其使用原理 powered by Gitbook该文件修订时间： 2019-08-25 23:46:48 "},"写在前面/我眼里的Vue.html":{"url":"写在前面/我眼里的Vue.html","title":"我眼里的Vue","keywords":"","body":"Vue是什么 Aaron目前脑海中对Vue认知可以用两个关键词来概括：响应式、组件化。因为Vue提供了便利的脚手架工具，所有的项目通过脚手架启动之后，已经集成了那一套全家桶的东西，Aaron打一开始使用就习惯把Vue当成一个框架而不是一个库，这种习惯其实很不好，下面重新认识一下Vue是什么 Vue.js是一个MVVM库 Vue.js是一个提供了MVVM(Model-View-ViewModel)风格的双向数据绑定的Javascript库，由View，ViewModel，Model三部分组成。View层代表的是视图、模版，负责将数据模型转化为UI展现出来。Model层代表的是模型、数据，可以在Model层中定义数据修改和操作的业务逻辑。ViewModel层连接Model和View。 Vue的核心库Vue.js只关注视图层，👇下面是一个简单的起步示例： {{ name }} is a boy // Model层 let data = { name: '小明' } // ViewModel层 const app = new Vue({ el: '#app', data: data }) 它是双向数据绑定的（响应式），Model层的数据变化会触发View层上引用到该数据的视图更新，同样在View层上对数据进行操作比如表单的输入，Model层的数据也会被动态地修改。 Vue框架支持模块化开发 Vue支持模块化开发。在Vue中可以使用Vue.component用来定义全局组件，紧接着用new Vue({ el: '#container '})在每个页面内指定一个容器元素，但是仅仅这样的话，如果要构建一个复杂的单页面应用的话，代码组织起来还是会很麻烦。所以Vue提供文件扩展名为.vue的单文件组件，源码里面的sfc目录的功能就是用来转换*.vue文件的，再结合打包构建工具，我们就能把每一个组件都拆分成一个个单文件，能够高效地去维护以及模块化地组织我们的项目代码。vue-cli为我们提供了快速启动的脚手架。 Vue框架具有完整的生态 Vue除了Vue.js核心库外，还有完整的生态，比如各种支持类库vuex、vue-router等 powered by Gitbook该文件修订时间： 2019-08-18 23:46:28 "},"写在前面/常见的MVM实现.html":{"url":"写在前面/常见的MVM实现.html","title":"MVM(VM)的实现原理","keywords":"","body":"常见的MVM(VM)的实现 我们知道Vue.js是一个了实现了MVVM的JavaScript库。在不同的库中，MVM(VM)的原理是不一样的，一共有下面三种👇： 发布-订阅模式（backbone.js） 脏检查机制（Angular.js） 数据劫持（Vue.js） 发布-订阅模式 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是vm.set('property', value)，但是我们更希望通过vm.property = value这种方式更新数据，同时自动更新视图，下面两种方式能够达到这种效果。 脏检查机制 angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下: DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持 对数据（Model）进行劫持，Vue2.x通过Object.defineProperty()来劫持各个属性的setter、getter，Vue3.0则通过proxy来“拦截”对各个属性的的设置和引用，当数据变动的时候就会触发劫持时绑定的事件，去执行视图更新的操作。 Vue的实现方式 数据劫持 + 发布者-订阅者模式。通过数据劫持，当数据变动的时候就发布消息给订阅者，触发响应的监听回调。 思考🤔：Vue为啥要同时使用：数据劫持 + 发布者-订阅者模式？ powered by Gitbook该文件修订时间： 2019-08-18 23:46:28 "},"写在前面/准备工作.html":{"url":"写在前面/准备工作.html","title":"阅读源码前的准备工作","keywords":"","body":"准备工作 确定版本 这个版本有两个意思，一个是具体的版本号，Aaron看的是2.6.10。另外一个是指vue打包后的功能版本，主要是Runtime Only和Runtime + compiler，区别就是前面一个需要编译工具去做预编译，它只保留了运行时的核心功能，后面一个则可以在客户端直接编译模板，Aaron看的是Runtime + compiler版本。 源码的目录结构 fork项目下来之后，我们可以看到目录结构如下： 目录结构.zip 阅读源码的时候我们只要关注src 目录里面的代码就可以了，同时flow 文件夹里面有对应的类型声明，一般不会去主动翻，在IDE里面装上对应的插件之后，它能够自动帮我们做类型校验，以及鼠标移动到声明过的对象上的时候还能进行智能提示，对我们阅读代码也有帮助。 🤔这里有个疑问：为啥flow和ts会同时存在？ 我快速浏览了一下，发现flow里有的声明，.d.ts里面好像也有对应的声明 test命令里面同时执行flow check 和 tsc ，但是tsc只对types 里面的.ts文件做测试 项目里面除了types 和packages 有部分.ts 文件，其他都是.js 文件，虽然ts也可以对js文件做校验，但是已经有了flow不至于这么骚的操作吧 最后才发现，原来types 是官方的类型声明文件，一同放在这里维护的，跟Vue源码开发没啥关系，当你想在Vue项目里集成ts的时候，拉下来的声明文件就是这份🤦‍，所以types 文件夹在我们阅读源码的时候也是忽略的 怎么去看 我们从package.json里面的dev命令入手，它的构建目标是web-full-dev，也就是Runtime + compiler的实时编译模式，它可以监控并实时编译出dist/vue.js。我们只需要在example里面新建一个demo网页，并引用dist/vue.js，这样子我们可以边修改Vue的源码边打断点进行调试了。 powered by Gitbook该文件修订时间： 2019-08-18 23:46:28 "},"写在前面/理解主线.html":{"url":"写在前面/理解主线.html","title":"理解主线","keywords":"","body":"理解主线 本章的目的是抛弃细节，把主线理清，我们从new一个Vue对象开始，一路断点下去看看Vue做了什么。 新建demo 首先运行npm run dev，然后在example文件夹下新建demo\\index.html，在里面我们写一个最简单的demo，并引用实时构建出来的dist/vue.js，然后在浏览器打开这份demo文件，通过调试可以一步一步地去查看Vue在初始化的时候经过了哪些步骤，把主线理清。 {{ num }} debugger; new Vue({ el: '#app', data() { return { num: 1 } } }) Vue的运行过程 我们知道Vue的核心流程是init -> mount -> render -> update -> patch -> dom，Aaron通过上面demo设置断点地把这个流程浅浅地过了一下，但是在new Watcher那里因为Aaron本身对依赖收集的这块的掌握得不好，所以在大脑中只是大概有一个轮廓。这也正好是Aaron这次要去解读Vue的原因，希望在这个过程中把这些没弄懂的核心的原理一一弄懂。 Aaron在社区里面发现一个运行流程图，前期暂时把它作为借鉴👇 powered by Gitbook该文件修订时间： 2019-08-18 23:46:28 "},"响应式系统/前置知识.html":{"url":"响应式系统/前置知识.html","title":"前置知识","keywords":"","body":"前置知识 Vue.js是通过数据劫持 + 发布者-订阅者模式来实现响应式功能的。 Object.defineProperty Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 通过Object.defineProperty()给某个属性设置get和set就可以劫持该属性的读写过程，具体的api使用我们不展开（MDN传送门），现在使用Object.defineProperty写个简单的小demo，来劫持一个对象的属性赋值和取值过程👇 function Store() { let data = null; Object.defineProperty(this, 'data', { get: function() { console.log('拦截到了，你在读取数据'); // 拦截到了，你在读取数据 return data; }, set: function(val) { console.log('拦截到了，你在设置数据'); // 拦截到了，你在设置数据 data = val; } }); } let store = new Store(); store.data = 'Hi'; console.log(store.data) // Hi Object.defineProperty的局限 Object.defineProperty只能劫持对象的某一个属性，当一个对象有嵌套的对象时，只能通过通过递归去给每一个属性设置拦截 Object.defineProperty并不能劫持Array.prototype上的方法。比如还是上面那个例子，当data是个数组的时候，对data调用push、pop等数组原型上的方法的时候，并不会触发setter: function Store() { let list = []; Object.defineProperty(this, 'list', { get: function() { console.log('拦截到了，你在读取数据'); // 拦截到了，你在读取数据 return list; }, set: function(val) { console.log('⚠️push操作并没有被拦截到'); list = val; } }); } let store = new Store(); store.list.push(1); console.log(store.list); // [1] 如何劫持数组上的方法 既然setter里面拦截不到原型链上的方法，那就针对数组原型链上的需要被拦截的方法进行二次封装。 function newArrMethod() { // 先把数组上的方法复制一遍 let arrExtend = Object.create(Array.prototype); // 然后把需要改写的方法重新封装，比如下面对push方法进行重新封装 let newPushMethod = function(...args) { console.log('在这里做拦截'); Array.prototype.push.apply(this, args); } arrExtend.push = newPushMethod; return arrExtend; } let arr = []; arr.__proto__ = newArrMethod(); arr.push(1); // arr的push方法被劫持到了 Proxy Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等） Proxy（MDN传送门）字面意思是代理，可以理解成，在目标对象之前架设一层 \"拦截\"，当外界对该对象访问的时候，都必须经过这层拦截，因此直接使用这个api就能够达到对象劫持的效果，vue2.*之所以不用Proxy而使用Object.defineProperty是因为Proxy是一个比较新的特性，考虑到浏览器的兼容性问题，所以没有被尤大使用。在vue3.0已经把Object.defineProperty替换为proxy，下面使用proxy来写一个劫持👇 let data = {}; data = new Proxy(data, { get: function(target, key) { console.log('拦截到了，你在读取数据'); return target[key]; }, set: function(target, key, val) { console.log('拦截到了，你在设置数据'); target[key] = val; } }) data.name = '小明'; console.log(data.name); 发布-订阅者模式 Vue.js里面的依赖收集是通过发布-订阅模式来实现的，这种设计模式在前端经常使用，比如document.addEventListener就是很典型发布-订阅者应用。一般来说发布-订阅模式有这几个要素： 有一个指定的发布者 发布者有一个缓存列表，里面存有所有订阅者的回调函数 发布消息的时候，发布者遍历缓存列表，依次触发订阅者的回调 👇下面实现一个典型的发布订阅者模式 class Event { constructor() { this.subscriberList = []; } listen(key, fn) { if (!this.subscriberList[key]) { this.subscriberList[key] = []; } this.subscriberList[key].push(fn); } notify() { let key = Array.prototype.shift.call(arguments); let fns = this.subscriberList[key]; fns && fns.forEach(fn => fn.apply(this, arguments)); } remove(key, fn) { let fns = this.subscriberList[key]; if (fns) { for (let i = fns.length - 1; i >= 0; i--) { let _fn = fns[i]; if (_fn == fn) { fns.splice(i, 1); } } } } } let event = new Event(); event.listen(\"sayHi\", function(name) { console.log(\"Hi，\" + name); }); event.listen(\"sayHallo\", function(name) { console.log(\"Hallo，\" + name); }); event.notify(\"sayHi\", \"小明\"); event.notify(\"sayHallo\", \"小红\"); powered by Gitbook该文件修订时间： 2019-08-18 23:46:28 "},"响应式系统/最小mvvm.html":{"url":"响应式系统/最小mvvm.html","title":"最小mvvm","keywords":"","body":"最小mvvm 我们先捋一下如果要实现一个最简单的变量和视图间的双向绑定的话需要考虑哪些东西。从一个简单的例子开始，有一个变量叫做myFriend，通过输入框可以改变它的值，重置按钮可以让它重置为空，然后页面上有两个p标签都引到了这个变量，可以把变量渲染出来，HTML代码如下👇，下面我们来一步步把这个Mvvm对象给实现了 mvvm 输入你朋友的姓名 重置 1、我认识 {{ myFriend }}； 2、我的朋友是 {{ myFriend }} var vm = new Mvvm({ el: '#app', data: { myFriend: '小明' }, methods: { reset() { this.myFriend = '' } } }); 首先我们先要拦截到数据变化 在前置知识里我们知道可以通过Object.defineProperty来给变量设置getter和setter，我们这里用一个函数封装一下👇 function defineReactive (data, key, val) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function () { // 待处理 return value; }, set: function (newVal) { if(value === newVal) return // 待处理 value = newVal } }) } defineReactive(this.data, 'myFriend', '小明') 由视图触发数据变更 其实就是通过页面上绑定的事件来变更数据，比如input输入、按钮点击回调、scroll回调等。我们暂时不去实现指令，留待后面去实现，这里我们先忽略@click和v-model，先直接去监听input事件和click事件，然后变更数据 document.getElementById('input').addEventListener('input', e => this.myFriend = e.target.value); document.getElementById('button').addEventListener('click', e => this.myFriend = ''); 由数据变更触发视图更新 数据变更之后，我们要让视图上引用了这些数据的地方重新渲染。在这个例子上，页面里只有两个p标签使用了myFriend这个变量，如果有更多的地方使用到这个变量呢？我们需要把所有使用到这个变量的地方都同时更新。所以这里我们要拆分成两个步骤，第一步是把页面上引用到该变量的地方都收集起来，这个叫做收集依赖，我们在getter中收集依赖，然后等到数据变化的时候，也就是在setter中再把这些收集到的依赖循环触发一次，让页面更新。就像下面这样👇 function defineReactive (data, key, val) { let dep = []; // 依赖列表 Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function () { dep.push(/* 引用了该变量的页面节点 */); return value; }, set: function (newVal) { if(value === newVal) return value = newVal dep.forEach(node => /* 遍历依赖中的元素节点然后渲染 */) } }) } defineReactive(this.data, 'myFriend', '小明') 实现mvvm类 理解上面需要的核心功能之后，我们就可以去思考如何实现mvvm这个类了，我们现在需要它实现下面这几个基础功能 挂载在#app下，直白说就是要把#app下所有的大括号插值变量做关联 把data代理到自身，比如我们在vue中更常用的是通过this.myFriend而不是通过this.data.myFriend去获取变量 获取指令并和变量做关联 实现变量的依赖收集和依赖更新 简单版实现如下👇 class Mvvm { constructor(options) { const { el, data, methods } = options; this.methods = methods; this.observe(data); this.compile(document.querySelector(el)); } observe(data) { for (let key in data) { this.defineReactive(this, key, data[key]); } } defineReactive(data, key, value) { let dep = []; Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function() { dep.push(this.target); return value; }, set: function(newVal) { if (value === newVal) return; value = newVal; dep.forEach(watcher => { watcher.update(value) }); } }); } compile(dom) { let nodes = dom.childNodes; for (let node of nodes) { const attrs = node.attributes || []; // 解析指令 for (const attr of attrs) { switch (attr.name) { case \"v-model\": node.addEventListener( \"input\", e => { this[attr.value] = e.target.value } ); this.target = new Watcher(node, \"input\"); this[attr.value]; break; case \"@click\": node.addEventListener(\"click\", () => this.methods[attr.value].call(this) ); break; } } let match = (node.innerText || \"\").match(/\\{\\{(.*)\\}\\}/); if (match) { const name = match[1].trim(); this.target = new Watcher(node, \"text\"); this[name]; } } } } class Watcher { constructor(node, type) { this.node = node; this.type = type; this.template = node.innerText; } update(value) { switch (this.type) { case \"input\": this.node.value = value; break; case \"text\": this.node.innerText = this.template.replace(/\\{\\{(.*)\\}\\}/g, value); break; } } } 这里有几个个地方要单独说一下： 第一个是抽象了一个watcher类，在这个demo里面数据只是被两个标签中的模板变量引用了，但是在vue中其实还有用户自身定义的watch也会在数据变更的时候触发用户自定义的回调。Wather其实扮演的就是一个中介的角色，数据变化的时候只要告诉watcher，watcher自己去通知引用到这个数据的其他地方。 第二个是target的巧妙运用，compile去解析模板的时候把获取到每一个依赖赋给一个全局性的target，然后去手动调一下触发一下引用变量的getter，在getter里面接收当前的target从而完成整个依赖收集的过程。 Dep其实应该单独抽象出来，目前还是耦合在一起 经过上面的例子我们就知道了一个核心的MVVM要实现的功能以及核心思路，然后我们再去看Vue的这块响应式的源码就比较有思路了。本节的后面我会参考Vue源码实现一个功能比较完整的MVVM。 powered by Gitbook该文件修订时间： 2019-08-25 23:38:31 "},"模板系统/实现一个模板引擎.html":{"url":"模板系统/实现一个模板引擎.html","title":"最小模板系统","keywords":"","body":"实现一个模板引擎 一个模板引擎会有什么功能： 模板获取 对模板进行变量分离 模板渲染 模板缓存 powered by Gitbook该文件修订时间： 2019-08-27 22:59:19 "}}